export interface AsyncStream<T> extends AsyncIterable<T> {
    filter(predicate: (_: T) => boolean): AsyncStream<T>;
    map<U>(transform: (_: T) => U): AsyncStream<U>;
    mapAwait<U>(transform: (_: T) => Promise<U>): AsyncStream<U>;
    flatMap<U>(transform: (_: T) => AsyncStream<U>): AsyncStream<U>;
    flatMapAwait<U>(transform: (_: T) => Promise<AsyncStream<U>>): AsyncStream<U>;
    batch(batchSize: number): AsyncStream<T[]>;
    limit(maxSize: number): AsyncStream<T>;
    skip(n: number): AsyncStream<T>;
    dropWhile(predicate: (_: T) => boolean): AsyncStream<T>;
    takeWhile(predicate: (_: T) => boolean): AsyncStream<T>;
    peek(observer: (_: T) => void): AsyncStream<T>;
    forEach(block: (_: T) => any | Promise<any>): Promise<void>;
    collect<A, R>(container: A, accumulator: (a: A, t: T) => void, finisher: (_: A) => R): Promise<R>;
    reduceLeft<R>(initial: R, accumulator: (r: R, t: T) => R): Promise<R>;
    reduce(accumulator: (a: T, b: T) => T): Promise<T | null>;
    all(predicate: (_: T) => boolean): Promise<boolean>;
    any(predicate: (_: T) => boolean): Promise<boolean>;
    none(predicate: (_: T) => boolean): Promise<boolean>;
    count(): Promise<number>;
    first(predicate: (_: T) => boolean): Promise<T | null>;
    last(predicate: (_: T) => boolean): Promise<T | null>;
    max(comparator: (a: T, b: T) => number): Promise<T | null>;
    min(comparator: (a: T, b: T) => number): Promise<T | null>;
    toArray(): Promise<T[]>;
}
export declare function asyncStreamIterable<T>(itrbl: Iterable<T>): AsyncStream<T>;
export declare function streamAsyncIterable<T>(itrbl: AsyncIterable<T>): AsyncStream<T>;
export declare function asyncStream<T>(it: Iterable<T> | AsyncIterable<T> | AsyncIterator<T, any>): AsyncStream<T>;
